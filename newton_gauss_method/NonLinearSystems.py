from sympy import *
import numpy as np
import matplotlib.pyplot as plt
from numpy import matrix
class NonLinearSystems(object):
    def __init__(self, equation, data, initial_guess=None):
        """
        Optimizes an equation such that the equation fits onto a set of data

        :param data: 2D list or numpy array with paired data of shape (None, 2)

                Example 1: data = [(x1, y1), (x2, y2), (x3, y3), ...]
                Example 2: data = [[x1, y1], [x2, y2], [x3, y3], ...]
                Example 3: data = np.array([(x1, y1), [x2, y2], (x3, y3), ...])

        :param equation: sympy symbolic equation to be optimized based
            on given datapoints

                Example: equation = Symbol('x')**2 + Symbol('A')
                    where Symbol('x') is the independent variable and must be present

        :param initial_guess: a dict where keys are symbols,
            values are corresponding symbolic values

            Example: initial_guess = {'a':6, 'b':3, ...}
        """
        self.data = np.array(data)
        self.equation = equation
        self.nonlinear_functions = [y_point - equation.subs('x', x_point)
                                    for x_point, y_point in data]
        self.parametric_symbols = [str(symbol) for symbol in list(equation.free_symbols) if
                                   str(symbol) != 'x']
        if initial_guess is None:
            self.initial_guess = {symbol: 1 for symbol in self.parametric_symbols}
        else:
            self.initial_guess = initial_guess
        self.jacobian = [
            [diff(func, symbol) for symbol in self.parametric_symbols]
            for func in self.nonlinear_functions
        ]
        self.params = {}

    def find_inverse_simple_jacobian(self, parameters):
        """
        Converts a given symbolic jacobian array into

        it's appropriate inverse jacobian matrix

        :param jacobian: a 2D list representing a sympy
            generated symbolic jacobian matrix

        :param parameters: dictionary where key's are function parameter
            symbols, values are their substitution value

        :return: np.array of the evaluated inverse_jacobian matrix
        """

        # Creates a new matrix
        new_jacobian = np.array(self.jacobian)

        # Turns symbolic expressions into floating point numbers
        newer_jacobian = [
            [
                float(
                    index.subs([
                        (symbol_key, parameters[symbol_key])
                        for symbol_key in self.parametric_symbols
                    ]))
                for index in item] for item in new_jacobian
        ]

        return np.array(matrix(newer_jacobian).I)

    def make_guess(self, guess=None):
        """
        Utilizes one cycle of Newton's Method for optimization based on a given guess

        :param guess: a dict where keys are parametric symbols, and values are
            parametric symbolic values to be substituted into the function during
            optimization

        :return: a dict of the newly optimized guess parameters
            where keys are parametric symbols and values are optimized values
        """

        if guess is None:
            guess = self.initial_guess
        start_val = [self.initial_guess[symbol] for symbol in self.parametric_symbols]
        evaluation = [float(func.subs([(symbol, self.initial_guess[symbol])
                                       for symbol in self.parametric_symbols]).evalf()) for
                      func in self.nonlinear_functions]

        inverse_jacobian = self.find_inverse_simple_jacobian(guess)
        result = start_val - np.matmul(inverse_jacobian, evaluation)
        for index, key in enumerate(self.parametric_symbols):
            self.initial_guess[key] = result[index]

    def fit(self, independent, best_fit=False):
        """
        Takes a list of independent values and generates yhat vals accordingly

        :param independent: a list of x values to fit
        :param best_fit: boolean deciding whether to return the optimized parameters
            with the least residual squared sum value opposed to the most recently
            optimized parameters
        :return: list of yhat points generated by the optimized parameters
        """
        if not best_fit:
            fit = self.equation.subs([(symbol, self.initial_guess[symbol]) for symbol in
                                      self.initial_guess])

        else:
            fit = self.equation.subs([(symbol, self.params['params'][symbol]) for symbol in
                                      self.initial_guess])
        newfit = lambda x: float(fit.subs('x', x).evalf())
        return [newfit(x) for x in independent]

    def train(self, cycles=7):
        """
        Internally updates objects parameters. Use this method to approximate
        parameter values

        :param cycles: Number of Newton Method cycles to iterate through
        """
        for _ in range(cycles):
            self.make_guess(self.initial_guess)

            print('Cycle: {0}'.format(_+1))
            data = self.data.T
            try:
                yhat = self.fit(self.data.T[0])
                residual_sum = sum([(data[1][index] - yhat[index]) ** 2 for index in range(len(data[0]))])

                if self.params == {}:
                    self.params = {'RSS': residual_sum, 'params': self.initial_guess}

                elif self.params['RSS'] > residual_sum:
                    self.params = {'RSS': residual_sum, 'params': self.initial_guess}

                print('Residual Squared Sum: {0}\n'.format(residual_sum))
            except KeyError:
                print("Whoops, that shouldn't happen")

    def __repr__(self):
        try:
            return str(self.equation.subs([(symbol, self.params['params'][symbol]) for symbol in self.parametric_symbols]))
        except KeyError:
            return 'Please Train!'